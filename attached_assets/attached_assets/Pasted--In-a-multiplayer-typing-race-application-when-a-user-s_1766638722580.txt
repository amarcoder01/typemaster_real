 In a multiplayer typing race application, when a user starts a "Live Race" (quick match), bots are supposed to join as opponents, but they don't appear and the race gets stuck on "Preparing..." indefinitely.
Expected Behavior: User clicks "Quick Match" â†’ Race is created with 3 AI bot opponents â†’ User can start the race â†’ Bots type alongside the user.
ğŸ” Step 1: Understand the Architecture
Before debugging, understand the system components:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚   Frontend      â”‚â”€â”€â”€â”€â–¶â”‚   REST API      â”‚â”€â”€â”€â”€â–¶â”‚   Database      â”‚â”‚   (React)       â”‚     â”‚   (Express)     â”‚     â”‚   (PostgreSQL)  â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚                       â”‚        â”‚                       â”‚        â–¼                       â–¼â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚   WebSocket     â”‚â—€â”€â”€â”€â–¶â”‚   Bot Service   â”‚â”‚   (Real-time)   â”‚     â”‚   (AI Typing)   â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Key Files to Investigate:
server/routes.ts - REST API endpoints for creating/joining races
server/websocket.ts - Real-time race communication
server/bot-service.ts - Bot creation and typing simulation
client/src/pages/race.tsx - Race UI component
ğŸ” Step 2: Trace the User Flow
Map out what should happen:
User clicks "Quick Match" â†’ POST /api/races/quick-match
Server creates race in database
Server should add bots â† Check this!
User joins race room via WebSocket
User clicks "Start Race" â†’ WebSocket sends ready message
Server validates player count
Countdown starts â†’ Race begins
Bots start typing
ğŸ” Step 3: Check If Bots Are Being Created
Search for bot creation code:
# Find where addBotsToRace is definedgrep -r "addBotsToRace" server/# Find where addBotsToRace is CALLEDgrep -r "botService.addBotsToRace" server/
What we found:
addBotsToRace() is defined in server/bot-service.ts
addBotsToRace() is never called anywhere!
Root Cause #1: The function exists but is never invoked.
ğŸ” Step 4: Check Player Count Validation
Find the race start logic:
grep -r "requiredPlayers\|NOT_ENOUGH_PLAYERS" server/
What we found in server/websocket.ts:
// This code requires 2 HUMAN playersconst requiredPlayers = 2;if (connectedHumans.length < requiredPlayers) {  // Error: Not enough players}
Root Cause #2: Even with bots, the server requires 2 humans to start.
ğŸ” Step 5: Check Data Caching
Understand the caching layer:
grep -r "raceCache" server/routes.ts
What we found:
Race cache is used for performance
When bots are added to DB, cache is NOT updated
handleReady reads from cache â†’ doesn't see bots
Root Cause #3: Stale cache data doesn't include bots.
ğŸ” Step 6: Check Frontend Error Handling
Find UI state management:
grep -r "isTransitioning\|Preparing" client/
What we found in client/src/pages/race.tsx:
// Sets "Preparing..." overlaysetIsTransitioning(true);setTransitionMessage("Preparing race...");// Error handler doesn't reset the state!case "NOT_ENOUGH_PLAYERS":  toast.warning("Not enough players");  // Missing: setIsTransitioning(false)  break;
Root Cause #4: UI gets stuck because error doesn't reset state.
ğŸ› ï¸ Step 7: Implement Fix #1 - Add Bots to Quick Match
File: server/routes.ts
Location: Inside POST /api/races/quick-match handler, after race is created
Code to Add:
// After: race = await storage.createRace({...});// Add bots to fill the race so players can start immediatelyconst botCount = 3;const addedBots = await botService.addBotsToRace(race.id, botCount);console.log([Quick Match] Added ${addedBots.length} bots to new race ${race.id});
ğŸ› ï¸ Step 8: Implement Fix #2 - Allow 1 Human + Bots
File: server/websocket.ts
Location: Inside handleReady() function, replace player count check
Code to Change:
// OLD:const requiredPlayers = 2;if (connectedHumans.length < requiredPlayers) { ... }// NEW:// Check if there are bots in the raceconst botParticipants = participants.filter(p => p.isBot === 1);const hasBots = botParticipants.length > 0;// With bots: 1 human needed. Without bots: 2 humans neededconst requiredHumans = hasBots ? 1 : 2;if (connectedHumans.length < requiredHumans) {  // Send appropriate error message}
ğŸ› ï¸ Step 9: Implement Fix #3 - Update Race Cache
File: server/routes.ts
Location: Before sending response in quick-match handler
Code to Add:
// Before: res.json({ race, participant });// Update race cache with all participants (including bots)const { raceCache } = await import("./race-cache");const allParticipants = await storage.getRaceParticipants(race.id);raceCache.setRace(race, allParticipants);
ğŸ› ï¸ Step 10: Implement Fix #4 - Reset UI on Error
File: client/src/pages/race.tsx
Location: Inside WebSocket message handler, error cases
Code to Add:
case "NOT_ENOUGH_PLAYERS":  toast.warning("Not enough players", {     description: message.message   });  setIsStarting(false);      // ADD THIS  setIsTransitioning(false); // ADD THIS  break;case "NOT_HOST":  toast.error("Permission denied");  setIsStarting(false);      // ADD THIS  setIsTransitioning(false); // ADD THIS  break;
ğŸ› ï¸ Step 11: Add Debug Logging
File: server/websocket.ts
Add logging to trace execution:
// In handleReady():console.log([WS] handleReady: Race ${raceId} has ${participants.length} participants);console.log([WS] handleReady: connectedHumans: ${connectedHumans.length}, hasBots: ${hasBots});if (!race) {  console.log([WS] handleReady: Race ${raceId} not found);  return;}if (race.status !== "waiting") {  console.log([WS] handleReady: Race ${raceId} not in waiting status);  return;}