1. server/routes.ts - Add Bots to Quick Match Races
Change 1: Add bots when creating a new race
routes.tsLines 65-83
        const roomCode = Math.random().toString(36).substring(2, 8).toUpperCase();        race = await storage.createRace({          roomCode,          status: "waiting",          raceType: effectiveRaceType,          timeLimitSeconds: effectiveRaceType === "timed" ? effectiveTimeLimit : null,          paragraphId,          paragraphContent,          maxPlayers: 8, // Allow up to 8 players, bots will be replaced when humans join          isPrivate: 0,        });                // Add bots to fill the race so players can start immediately        // Add 3 bots by default (making it a 4-player race with the human)        const botCount = 3;        const addedBots = await botService.addBotsToRace(race.id, botCount);        console.log([Quick Match] Added ${addedBots.length} bots to new race ${race.id});      }
Change 2: Update race cache after creating participant
          participant = await storage.createRaceParticipant({            raceId: race.id,            userId: user?.id,            guestName: user ? undefined : guestId,            username,            avatarColor,            progress: 0,            wpm: 0,            accuracy: 0,            errors: 0,            isFinished: 0,            isBot: 0,          });        }      }      // Update race cache with all participants (including bots)      // This ensures handleReady sees the bots when checking if race can start      const { raceCache } = await import("./race-cache");      const allParticipants = await storage.getRaceParticipants(race.id);      raceCache.setRace(race, allParticipants);      console.log([Quick Match] Updated race cache with ${allParticipants.length} participants (bots: ${allParticipants.filter(p => p.isBot === 1).length}));      res.json({ race, participant });
2. server/websocket.ts - Allow 1 Human + Bots to Start
Change 1: Add debug logging for race status check
    if (!race) {      console.log([WS] handleReady: Race ${raceId} not found);      return;    }        if (race.status !== "waiting") {      console.log([WS] handleReady: Race ${raceId} is not in waiting status (current: ${race.status}));      return;    }        console.log([WS] handleReady: Race ${raceId} has ${participants.length} participants (bots: ${participants.filter(p => p.isBot === 1).length}))
Change 2: Check for bots and adjust required humans
    // Use connected clients (not DB participants) for live player count    // This handles kicked/disconnected players correctly    const connectedClients = Array.from(raceRoom.clients.values());    const connectedHumans = connectedClients.filter(c => !c.isBot);        // Check if there are bots in the race (from DB participants)    const botParticipants = participants.filter(p => p.isBot === 1);    const hasBots = botParticipants.length > 0;        // Minimum players required:    // - With bots: 1 human (bots will race alongside)    // - Without bots: 2 humans (like TypeRacer)    const requiredHumans = hasBots ? 1 : 2;        console.log([WS] handleReady: Race ${raceId} - connectedHumans: ${connectedHumans.length}, hasBots: ${hasBots}, requiredHumans: ${requiredHumans});        if (connectedHumans.length < requiredHumans) {      // Not enough connected human players      const client = raceRoom.clients.get(participantId);      if (client && client.ws.readyState === WebSocket.OPEN) {        if (hasBots) {          client.ws.send(JSON.stringify({            type: "error",            message: "No connected players found. Please refresh and try again.",            code: "NOT_ENOUGH_PLAYERS"          }));        } else {          const needed = requiredHumans - connectedHumans.length;          client.ws.send(JSON.stringify({            type: "error",            message: Need ${needed} more player${needed > 1 ? 's' : ''} to start. Share your room code with friends!,            code: "NOT_ENOUGH_PLAYERS"          }));        }      }      return;    }
Change 3: Add logging before starting countdown
    // Set starting flag to prevent double-start    raceRoom.isStarting = true;        console.log([WS] handleReady: Starting countdown for race ${raceId});        try {      await this.startCountdown(raceId);    } catch (error) {      raceRoom.isStarting = false;      console.error([WS] Failed to start countdown for race ${raceId}:, error);    }
3. client/src/pages/race.tsx - Reset UI State on Errors
Change 1: Reset "Preparing" state on NOT_HOST error
          case "NOT_HOST":            toast.error("Permission denied", {               description: message.message || "Only the host can do this",              duration: 3000            });            setIsStarting(false);            setIsTransitioning(false);            break;
Change 2: Reset "Preparing" state on NOT_ENOUGH_PLAYERS error
          case "NOT_ENOUGH_PLAYERS":            toast.warning("Not enough players", {               description: message.message || "Need at least 2 players to start",              duration: 4000            });            setIsStarting(false);            setIsTransitioning(false);            break;
Summary of Files Changed
File	What Changed
server/routes.ts	Added botService.addBotsToRace() call + cache update
server/websocket.ts	Check for bots, allow 1 human to start, added debug logs
client/src/pages/race.tsx	Reset UI state on errors